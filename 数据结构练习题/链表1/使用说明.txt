1.调试如下程序，理解顺序(数组)存储，物理顺序和逻辑顺序相同并且连续


2.调试如下程序，理解链式存储线性表，物理顺序和逻辑顺序可能不同，并且各物理单元不连续


3.递归算法如下，在纸上写出调用fun(1234)时的运行结果。然后自己添加主函数验证，理解递归调用的执行过程(展开和回归)、递归出口和递归体


4.递归算法如下，在纸上写出调用fun(1234)时的运行结果。然后自己添加主函数验证，理解递归调用的执行过程(展开和回归)、递归出口和递归体。


5.递归算法如下，在纸上写出调用fun(4)时的运行结果。然后自己添加主函数验证，理解递归调用的执行过程(展开和回归)、递归出口和递归体。


6.递归算法如下，①先在纸上写出调用语句fun(a,0,9)的返回结果，其中实参a数组定义并初始化为：int  a[10]={3,2,1,6,5,4,9,8,7,10}；②该fun函数一共被调用了几次。自己添加主函数验证理解。


7.调试并理解线性表顺序存储的实现，如线性表结构定义、初始化、插入元素、删除元素、遍历显示、清空等。


8.用顺序存储实现教材算法2.1求两集合并集。提示：在第一题代码中添加Qbingji函数和Qbingji1函数分别使用自定义函数和不使用自定义函数求并集，并修改主函数调用验证。主函数调用Qbingji个Qbingji1执行结果是一样的。


9.用顺序存储实现教材算法2.2将两非递减线性表合并后仍非递减；写两个函数，一个使用线性表操作自定义函数，一个不使用自定义函数。


10.参考求并集思想，用顺序存储实现求两集合的交集，写两个函数，一个使用线性表操作自定义操作函数，一个不使用。


11.初始化n个整数到一维数组R中。设计一个时间和空间两方面尽可能高效的算法void  fun(int  R[],int  n,int  p)，将R中整数序列循环左移p（p大于0小于n）个位置，即将R中的数据序列（X0,X1,…,Xn-1）变换为（Xp,Xp+1,  …,Xn-1,X0,X1,…,Xp-1），
（1）算法设计思想：先将这n个元素的数据序列（X0,X1,…,  Xp-1,Xp,…,Xn-1）原地逆置，得到的数据序列为（Xn-1,…,  Xp,Xp-1,…,X1,  X0），然后再将前n-p个元素（Xn-1,…,  Xp）和后p个元素（Xp-1,…X1,  X0）分别原地逆置，得到最终结果（Xp,Xp+1,  …,Xn-1,X0,X1,…Xp-1）。
算法可以先定义一函数void  reverse(int  R[],int  left,int  right)，实现数组R[left…right]的逆置，然后fun()函数调用reverse()三次。